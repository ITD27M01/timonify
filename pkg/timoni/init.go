package timoni

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
)

const timoniIgnore = `
# VCS
.git/
.gitignore
.gitmodules
.gitattributes

# Go
vendor/
go.mod
go.sum

# CUE
*_tool.cue
debug_values.cue
`

const defaultTimonifile = `// Code generated by timoni.
// Note that this file is required and should contain
// the values schema and the timoni workflow.

package main

import (
	templates "timoni.sh/%s/templates"
)

// Define the schema for the user-supplied values.
// At runtime, Timoni injects the supplied values
// and validates them according to the Config schema.
values: templates.#Config

// Define how Timoni should build, validate and
// apply the Kubernetes resources.
timoni: {
	apiVersion: "v1alpha1"

	// Define the instance that outputs the Kubernetes resources.
	// At runtime, Timoni builds the instance and validates
	// the resulting resources according to their Kubernetes schema.
	instance: templates.#Instance & {
		// The user-supplied values are merged with the
		// default values at runtime by Timoni.
		config: values
		// These values are injected at runtime by Timoni.
		config: {
			metadata: {
				name:      string @tag(name)
				namespace: string @tag(namespace)
			}
			moduleVersion: string @tag(mv, var=moduleVersion)
			kubeVersion:   string @tag(kv, var=kubeVersion)
		}
	}

	// Pass Kubernetes resources outputted by the instance
	// to Timoni's multi-step apply.
	%s
}
`

const defaultModuleCue = `module: "timoni.sh/%s"`

var moduleName = regexp.MustCompile("^[a-zA-Z0-9._-]+$")

const maxModuleNameLength = 250

// initModuleDir - creates timoni module structure in moduleName directory if not presented.
func initModuleDir(moduleDir, moduleName string, crd bool) error {
	if err := validateModuleName(moduleName); err != nil {
		return err
	}

	cDir := filepath.Join(moduleDir, moduleName)
	_, err := os.Stat(filepath.Join(cDir, "timoni.cue"))
	if os.IsNotExist(err) {
		return createCommonFiles(moduleDir, moduleName, crd)
	}
	logrus.Info("Skip creating module skeleton: timoni.cue already exists.")
	return err
}

func validateModuleName(name string) error {
	if name == "" || len(name) > maxModuleNameLength {
		return fmt.Errorf("module name must be between 1 and %d characters", maxModuleNameLength)
	}
	if !moduleName.MatchString(name) {
		return fmt.Errorf("module name must match the regular expression %q", moduleName.String())
	}
	return nil
}

func createCommonFiles(moduleDir, moduleName string, crd bool) error {
	cDir := filepath.Join(moduleDir, moduleName)
	err := os.MkdirAll(filepath.Join(cDir, "templates"), 0750)
	if err != nil {
		return fmt.Errorf("%w: unable create module/templates dir", err)
	}
	err = os.MkdirAll(filepath.Join(cDir, "cue.mod"), 0750)
	if err != nil {
		return fmt.Errorf("%w: unable create module/cue.mod dir", err)
	}
	createFile := func(content []byte, path ...string) {
		if err != nil {
			return
		}
		file := filepath.Join(path...)
		err = os.WriteFile(file, content, 0640)
		if err == nil {
			logrus.WithField("file", file).Info("created")
		}
	}
	createFile(timoniCue(moduleName, crd), cDir, "timoni.cue")
	createFile([]byte(timoniIgnore), cDir, "timoni.ignore")
	createFile([]byte(fmt.Sprintf(defaultModuleCue, moduleName)), cDir, "cue.mod", "module.cue")
	vendorK8s := exec.Command("timoni", "mod", "vendor", "k8s", cDir)
	if err = vendorK8s.Run(); err != nil {
		return fmt.Errorf("%w: unable to vendor k8s module", err)
	}
	vendorTimoni := exec.Command("timoni", "artifact", "pull", "oci://ghcr.io/stefanprodan/timoni/schemas", "-o", filepath.Join(cDir, "cue.mod/pkg"))
	if err = vendorTimoni.Run(); err != nil {
		return fmt.Errorf("%w: unable to vendor timoni schemas", err)
	}
	return err
}

func timoniCue(appName string, crd bool) []byte {
	timoniFile := defaultTimonifile
	apply := "apply: app: [for obj in instance.objects {obj}]"
	if crd {
		apply = "apply: crds: [for crd in instance.crds {crd}]\n" + apply
	}
	return []byte(fmt.Sprintf(timoniFile, appName, apply))
}
